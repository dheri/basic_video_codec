import concurrent
import csv
import logging
import os
import time
from io import BufferedWriter

import numpy as np
from matplotlib import pyplot as plt

from common import mae, pad_frame

logging.basicConfig(format='%(asctime)s.%(msecs)03d %(levelname)-7s [%(filename)s:%(lineno)d] %(message)s',
    datefmt='%H:%M:%S',
    level=logging.DEBUG)
logger = logging.getLogger()
logger.setLevel(logging.INFO)
def find_lowest_mae_block(curr_block, prev_partial_frame, block_size):
    """Find the block with the lowest MAE from a smaller previous partial frame."""
    height, width = prev_partial_frame.shape
    min_mae = float('inf')
    best_mv = [0,0]  # motion vector wrt origin of prev_partial_frame

    # Loop through all possible positions in the previous partial frame

    for ref_y in range(0, height - block_size + 1):
        for ref_x in range(0, width - block_size + 1):
            ref_block = prev_partial_frame[ref_y:ref_y + block_size, ref_x:ref_x + block_size]
            error = mae(curr_block, ref_block)

            # Update best match if a lower MAE is found, breaking ties as described
            if error < min_mae or (error == min_mae and abs(ref_x) + abs(ref_y) < abs(best_mv[0]) + abs(best_mv[1])):
                min_mae = error
                best_mv = [ref_x , ref_y]  # (dx, dy)



    return best_mv, min_mae, ref_block

def process_frame(curr_frame, prev_frame, block_size, search_range, residual_approx_factor):
    if curr_frame.shape != prev_frame.shape:
        raise ValueError("Motion estimation got mismatch in frame shapes")
    height, width = curr_frame.shape
    num_of_blocks = (height // block_size) * (width // block_size)
    mv_field = {}
    residuals = {}
    avg_mae = 0

    # Function to process each block (for threading)
    def process_block(y, x):
        curr_block = curr_frame[y:y + block_size, x:x + block_size]

        prev_partial_frame_y_start_idx = max(y - search_range, 0)
        prev_partial_frame_x_start_idx = max(x - search_range, 0)
        prev_partial_frame_y_end_idx = min(y + block_size + search_range, height)
        prev_partial_frame_x_end_idx = min(x + block_size + search_range, width)

        prev_partial_frame = prev_frame[prev_partial_frame_y_start_idx:prev_partial_frame_y_end_idx,
                                        prev_partial_frame_x_start_idx:prev_partial_frame_x_end_idx]
        # residual_wo_mc = curr_frame[y:y + block_size, x:x + block_size] - prev_frame[y:y + block_size, x:x + block_size]

        best_mv_wrt_ppf, mae_value, predicted_block = find_lowest_mae_block(curr_block, prev_partial_frame, block_size)

        # (d) An (𝑖 × 𝑖) residual block will be generated by subtracting the predicted block from the current block
        residual_block = np.subtract(curr_block, predicted_block)
        # (e) Generate an approximated residual block by rounding every element in the (𝑖 × 𝑖) residual block
        # to the nearest multiple of 2^n (for 𝑛 = 1, 2, 3)
        approx_residual_w_predicted_b = round_to_nearest_multiple(residual_block, residual_approx_factor)

        # change mv to curr block's frame of reference
        best_mv = [prev_partial_frame_x_start_idx + best_mv_wrt_ppf[0] - x,
                   prev_partial_frame_y_start_idx + best_mv_wrt_ppf[1] - y]

        reconstructed_block = approx_residual_w_predicted_b + predicted_block
        return (x, y), best_mv, mae_value, approx_residual_w_predicted_b, reconstructed_block


    reconstructed_frame = np.zeros_like(curr_frame)
    residual_frame = np.zeros_like(curr_frame)
    with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
        futures = []
        for y in range(0, height, block_size):
            for x in range(0, width, block_size):
                futures.append(executor.submit(process_block, y, x))

        # Collect the results as they complete
        for future in concurrent.futures.as_completed(futures):
            block_cords, mv, mae_value, residual_b, reconstructed_b = future.result()
            x=block_cords[0]
            y=block_cords[1]

            # (i) A Y-only-reconstructed file will be constructed from the reconstructed (𝑖 × 𝑖) blocks
            reconstructed_frame[y:y + block_size, x:x + block_size] = reconstructed_b
            residual_frame[y:y + block_size, x:x + block_size] = residual_b

            mv_field[block_cords] = mv
            residuals[block_cords] = residual_b
            avg_mae += mae_value

    avg_mae /= num_of_blocks
    return mv_field, avg_mae, residuals, reconstructed_frame, residual_frame


def plot_metrics(avg_mae, file_prefix, block_size, search_range):
    avg_mae_values = avg_mae  # Extract avg_mae for each frame
    frame_numbers = range(1, len(avg_mae_values) + 1)  # Generate frame numbers

    plt.figure(figsize=(10, 6))
    plt.plot(frame_numbers, avg_mae_values, marker='o', linestyle='-', color='b', label='Avg MAE')

    plt.title(f'MAE per Frame, i = {block_size}, r = {search_range}')
    plt.xlabel('Frame Number')
    plt.ylabel('Average MAE')
    plt.grid(True)
    plt.legend(loc='upper right')
    plt.tight_layout()
    plt.savefig(f'{file_prefix}_mae.png')

    plt.close()
    # Write the MAE values to a CSV file
    csv_file = f'{file_prefix}_mae.csv'
    with open(csv_file, 'wt') as f:
        for frame, mae in zip(frame_numbers, avg_mae_values):
            f.write(f'{frame}, {mae}\n')  # Write frame number and corresponding MAE value


def write_to_file(file_handle : BufferedWriter , frame_idx , data, new_line_per_block = False):
    # file_handle.write(f'\nFrame: {frame_idx}\n')
    new_line_char = f'\n' if new_line_per_block else ''
    for k in sorted(data.keys()):
        file_handle.write(f'{new_line_char}{k[0]},{k[1]}:{data[k][0]},{data[k][1]}|')
    file_handle.write('\n')


def round_to_nearest_multiple(arr, n):
    multiple = 2 ** n
    return np.round(arr / multiple) * multiple

def write_y_only_frame(file_handle, reconstructed_frame):
    file_handle.write(reconstructed_frame.tobytes())

def encoder(input_file, mv_output_file, residual_txt_file, residual_yuv_file, reconstructed_file, frames_to_process, height, width, block_size, search_range, residual_approx_factor):
    start_time = time.time()
    y_size = width * height
    prev_frame = np.full((height, width), 128, dtype=np.uint8)
    avg_mae_per_frame = list()
    with open(input_file, 'rb') as f_in, open(mv_output_file, 'wt') as mv_fh, open(residual_txt_file, 'wt') as residual_txt_fh, open(residual_yuv_file, 'wb') as residual_yuv_fh, open(reconstructed_file, 'wb') as reconstructed_fh:
        frame_index = 0
        while True:
            frame_index += 1
            y_frame = f_in.read(y_size)
            if not y_frame or frame_index > frames_to_process:
                break  # End of file or end of frames
            logger.debug(f"Processing frame {frame_index}/{frames_to_process}")
            y_plane = np.frombuffer(y_frame, dtype=np.uint8).reshape((height, width))
            padded_frame = pad_frame(y_plane, block_size)

            logger.info(f"Frame {frame_index }, Block Size {block_size}x{block_size}, Search Range {search_range}")
            mv_field, avg_mae, residual, reconstructed_frame, residual_frame = process_frame(padded_frame, prev_frame, block_size, search_range, residual_approx_factor)

            write_to_file(mv_fh, frame_index, mv_field)
            # write_to_file(residual_txt_fh, frame_index, residual, True)
            write_y_only_frame(reconstructed_fh, reconstructed_frame)
            write_y_only_frame(residual_yuv_fh, residual_frame)

            logger.info(f"Average MAE for Block Size {block_size} and Search Range {search_range}: {avg_mae}")
            avg_mae_per_frame.append(avg_mae)
            prev_frame = reconstructed_frame


    end_time = time.time()
    elapsed_time = end_time - start_time

    num_of_blocks = (height // block_size) * (width // block_size)
    num_of_comparisons = num_of_blocks * (2 * search_range + 1) ** 2
    result = str(f"{num_of_comparisons/elapsed_time:9.3f} | {num_of_comparisons:7d} | {num_of_blocks/elapsed_time:7.3f} |  {num_of_blocks:5d} | {frames_to_process/elapsed_time:6.2f} | {frames_to_process:3d} | {elapsed_time:6.3f} | {block_size:2d} | {search_range:2d} |\n")
    print(result)
    with open('results.csv', 'at') as f_in:
        f_in.write(result)
    print('end encoding')
    return  avg_mae_per_frame

def parse_mv(mv_str: str):
    mv_field = {}
    mv_blocks = mv_str.strip().split('|')
    for b in mv_blocks[:-1]: # ignore last element which will be empty
        kv_pairs = b.split(':')
        cords_txt = kv_pairs[0].split(',')
        mv_txt = kv_pairs[1].split(',')
        cords = (int(cords_txt[0]), int(cords_txt[1]))
        mv = [int(mv_txt[0]), int(mv_txt[1])]
        mv_field[cords] = mv
    return mv_field


def find_predicted_block(mv, x, y, prev_frame, block_size):
    predicted_block = prev_frame[y + mv[1]:y + mv[1] + block_size, x + mv[0]:x + mv[0] + block_size]
    return predicted_block

def decode_frame(residual_frame, prev_frame, mv_frame, height, width, block_size):
    decoded_frame = np.zeros_like(prev_frame)

    for y in range(0, height, block_size):
        for x in range(0, width, block_size):
            residual_block = residual_frame[y:y + block_size, x:x + block_size]
            predicted_b = find_predicted_block(mv_frame[(x,y)], x,y,prev_frame, block_size)

            decoded_block = residual_block + predicted_b
            
            decoded_frame[y:y + block_size, x:x + block_size] = decoded_block
    return decoded_frame


def decoder(residual_yuv_file, mv_txt_file, block_size, decoded_yuv, height, width, frames_to_process):
    frame_size = width * height
    prev_frame = np.full((height, width), 128, dtype=np.uint8)

    with open(residual_yuv_file, 'rb') as residual_yuv_fh, open(mv_txt_file,'rt') as mv_txt_fh, open(decoded_yuv, 'wb') as decoded_fh:
        frame_index = 0
        while True:
            frame_index += 1
            y_frame = residual_yuv_fh.read(frame_size)
            mv_txt =  mv_txt_fh.readline()
            if not y_frame or frame_index > frames_to_process or not mv_txt:
                break  # End of file or end of frames
            logger.debug(f"Decoding frame {frame_index}/{frames_to_process}")
            residual_frame = np.frombuffer(y_frame, dtype=np.uint8).reshape((height, width))
            mv = parse_mv(mv_txt)

            decoded_frame = decode_frame(residual_frame, prev_frame, mv, height, width, block_size)
            write_y_only_frame(decoded_fh, decoded_frame)

            prev_frame = decoded_frame
    print('end decoding')

def main(input_file, width, height):

    file_prefix = os.path.splitext(input_file)[0]
    input_file = f'{file_prefix}.y'

    search_ranges = [1, 2, 4, 8]  # Search ranges to test
    block_sizes = [2, 8, 16, 64]  # Block sizes to process
    search_range = search_ranges[1]
    block_size = block_sizes[1]  # Block sizes to process 'i'
    residual_approx_factor = 5
    frames_to_process = 11

    # Assuming a previous frame of all 128 (as specified for the first frame)


    file_identifier = f'{block_size}_{search_range}_{residual_approx_factor}'

    mv_output_file = f'{file_prefix}_{file_identifier}_mv.txt'
    residual_txt_file = f'{file_prefix}_{file_identifier}_residuals.txt'
    residual_yuv_file = f'{file_prefix}_{file_identifier}_residuals.yuv'
    reconstructed_file = f'{file_prefix}_{file_identifier}_recons.yuv'
    decoded_yuv = f'{file_prefix}_{file_identifier}_decoded.yuv'

    if os.path.exists(residual_yuv_file):
        logger.info(f" {residual_yuv_file} already exists. skipping encoding..")
    else:
        avg_mae_per_frame = encoder(input_file, mv_output_file, residual_txt_file, residual_yuv_file, reconstructed_file, frames_to_process, height, width, block_size, search_range, residual_approx_factor)
        plot_metrics(avg_mae_per_frame, f'{file_prefix}_{file_identifier}', block_size, search_range)

    decoder(residual_yuv_file, mv_output_file, block_size, decoded_yuv, height, width, frames_to_process)


